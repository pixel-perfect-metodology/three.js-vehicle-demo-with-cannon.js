import {
  CollideEvent,
  CompoundBodyProps,
  CylinderProps,
  useCompoundBody,
  useCylinder
} from "use-cannon/packages/react-three-cannon/src";
// } from "@react-three/cannon";
import { useGLTF } from "@react-three/drei";
import {
  CHASSIS,
  CUBE,
  PILLAR,
  SURFACE_FOR_PAINT,
  WHEEL
} from "../ObjectCollisionTypes";
import { forwardRef, Ref, useContext, useState } from "react";
import { Euler, Vector3 } from "@react-three/fiber";
import { Mesh, Object3D } from "three";
import { ControlsContext } from "hooks/useControls";

const filePath = "/all-terrain-vehicle-wheel.textured.glb";

const halfMathPI = Math.PI / 2;
const wheelDepthScale = 0.33;
const wheelMeshDepthScale = 0.493;
const wheelMeshRadiusScale = 0.59;
const wheelPhysicsRadiusScale = 0.625;

type WheelProps = CylinderProps & {
  radius?: number;
  depth?: number;
  leftSide?: boolean;
  printCollisionInfo?: boolean;
  name?: string;
};

const Wheel = forwardRef(
  (
    {
      radius = 1.0,
      depth = 1,
      leftSide = false,
      printCollisionInfo = false,
      name,
      ...props
    }: WheelProps,
    ref: Ref<Object3D<Event>> | undefined
  ) => {
    const { nodes, materials } = useGLTF(filePath);
    const scaledWheelDepth = depth * wheelDepthScale;
    const wheelPhysicsRadius = radius * wheelPhysicsRadiusScale;

    const onCollideHandler = function (e: CollideEvent) {
      if (
        e.body.name !== "pillar" &&
        e.body.name !== "cube" &&
        e.target.name === "surface-for-paint"
      ) {
        debugger;
      }
      // if (e.body.userData.id === "floor_0:0:0") {
      //   // if (e.body.userData.id === "wheel-front-first-axis-left") {
      //   // console.log("collision with wheel", e.body.userData);
      //   // console.log(arguments);
      //   if (logs.length < 10) {
      //     logs.push({ e, arguments });
      //   }
      // }
    };

    // refs[bodyB].name !== 'pillar' && refs[bodyB].name !== 'cube' /*&& !(refs[bodyA].name.startWith('wheel') || refs[bodyB].name.startWith('wheel'))*/
    // /// ////
    // (_ref2.collisionFilters.bodyFilterGroup === 2 &&
    //  _ref2.collisionFilters.bodyFilterGroup === 1)
    //  ||
    // (_ref2.collisionFilters.bodyFilterGroup === 2 &&
    //  _ref2.collisionFilters.bodyFilterGroup === 8)

    let wheelCompoundBodyOptions: CompoundBodyProps = {
      mass: 50,
      // type: "Kinematic",///////////////////////////////////////////////<<<<<<<<<<<<<<<<
      material: "wheel",
      collisionFilterGroup: 0, // for debug - to ignore wheel and chassis buggy collision from incorrect calculation of wheel position <<<<<<<<< ////////////////////   *********
      // collisionFilterGroup: WHEEL,
      collisionFilterMask: CHASSIS | WHEEL | SURFACE_FOR_PAINT | PILLAR | CUBE,
      shapes: [
        {
          type: "Cylinder",
          rotation: [0, 0, (leftSide ? +1 : -1) * halfMathPI],
          args: [wheelPhysicsRadius, wheelPhysicsRadius, scaledWheelDepth, 16]
        }
      ],
      ...props
    };

    if (printCollisionInfo) {
      wheelCompoundBodyOptions.onCollide = onCollideHandler;
    }

    useCompoundBody(() => wheelCompoundBodyOptions, ref);

    const scaledWheelMeshDepth = scaledWheelDepth * wheelMeshDepthScale;
    const wheelMeshRadius = radius * wheelMeshRadiusScale;

    const scale = [
      wheelMeshRadius,
      scaledWheelMeshDepth,
      wheelMeshRadius
    ] as Vector3;
    const position = [
      (leftSide ? +1 : -1) * scaledWheelMeshDepth,
      0,
      0
    ] as Vector3;
    const rotation = [0, 0, (leftSide ? +1 : -1) * halfMathPI] as Euler;

    const { showWireframe } = useContext(ControlsContext);

// @ts-expect-error
    (nodes["wheel-all-terrain_1"] as Mesh).material.wireframe = showWireframe;
    // @ts-expect-error
    (nodes["wheel-all-terrain_2"] as Mesh).material.wireframe = showWireframe;
    /*
    geometry and material was generated by gltfjsx
    Auto-generated by: https://github.com/pmndrs/gltfjsx
    Command: npx gltfjsx@6.1.4 wheel.glb --transform
    */
    return (
      // @ts-expect-error
      <group ref={ref} name={name || "wheel"}>
        <axesHelper
          name="chassis-helper"
          // @ts-expect-error
          position={ref?.current?.position.toArray()}
        />
        <group
          scale={scale}
          position={position}
          rotation={rotation}
          name="wheel-inner-mesh-position-group"
        >
          <axesHelper
            name="chassis-helper-inner"
            // @ts-expect-error
            position={ref?.current?.position.toArray()}
          />
          <mesh
            name="tire"
            castShadow
            receiveShadow
            // @ts-expect-error
            geometry={nodes["wheel-all-terrain_1"].geometry}
            material={materials.Rubber}
          />
          <mesh
            name="wheel-disk"
            castShadow
            receiveShadow
            // @ts-expect-error
            geometry={nodes["wheel-all-terrain_2"].geometry}
            material={materials["Paint.Gray"]}
          />
        </group>
      </group>
    );
  }
);

useGLTF.preload(filePath); // todo replace on adding the resource to the resource loading manager queue

export default Wheel;
